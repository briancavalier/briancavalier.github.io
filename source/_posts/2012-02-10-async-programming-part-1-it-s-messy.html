---
layout: post
title: ! 'Async Programming Part 1: It''s Messy'
published: true
---
<h1>Exceptions and try/catch</h1>

<p>Exceptions and try/catch are an intuitive way to execute operations that may fail.  They allow us to recover from the failure, or to let the failure propagate up the call stack to a caller by either not catching the exception, or explicitly re-throwing it.</p>

<p>Here&rsquo;s a simple example:</p>

<p><script src="https://gist.github.com/1790802.js"></script></p>

<p>In this case, <code>getTheResult</code> handles the case where <code>thisMightFail</code> does indeed fail and throws an <code>Error</code> by catching the <code>Error</code> and calling <code>recoverFromFailure</code> (which could return some default result, for example).  This works because <code>thisMightFail</code> is <em>synchronous</em>.</p>

<h1>Going Async</h1>

<p>What if <code>thisMightFail</code> is <em>asynchronous</em>?  For example, it may perform an asynchronous XHR to fetch the result data:</p>

<p><script src="https://gist.github.com/1790814.js"></script></p>

<p>Now it&rsquo;s impossible to use try/catch, and we have to supply a callback and errback to handle the success and failure cases.  That&rsquo;s pretty common in Javascript applications, so no big deal, right?  But wait, now <code>getTheResult</code> <em>also</em> has to change:</p>

<p><script src="https://gist.github.com/1790818.js"></script></p>

<p>At the very least, <code>callback</code> (and possibly <code>errback</code>, read on) must now be added to <em>every function signature</em> all the way back up to the caller who is ultimately interested in the result.</p>

<h2>More Async</h2>

<p>If <code>recoverFromFailure</code> is also asynchronous, we have to add yet another level of callback nesting:</p>

<p><script src="https://gist.github.com/1790822.js"></script></p>

<p>This also raises the question of what to do if <code>recoverFromFailure</code> itself fails.  When using synchronous try/catch, <code>recoverFromFailure</code> could simply throw an <code>Error</code> and it would propagate up to the code that called <code>getTheResult</code>.  To handle an asynchronous failure, we have to introduce another <code>errback</code>, resulting in both <code>callback</code> and <code>errback</code> infiltrating every function signature from <code>recoverFromFailure</code> all the way up to a caller who must ultimately supply them.</p>

<p>It may also mean that we have to check to see if callback and errback were actually provided, and if they might throw exceptions:</p>

<p><script src="https://gist.github.com/1790826.js"></script></p>

<p>The code has gone from a simple try/catch to deeply nested callbacks, with <code>callback</code> and <code>errback</code> in every function signature, plus additional logic to check whether it&rsquo;s safe to call them, and, ironically, <em>two try/catch blocks</em> to ensure that <code>recoverFromFailure</code> can indeed recover from a failure.</p>

<h2>And what about finally?</h2>

<p>Imagine if we were also to introduce <code>finally</code> into the mix&mdash;things would need to become even more complex.  There are essentially two options, neither of which is as simple and elegant as the language-provided <code>finally</code> clause. We could: 1) add an <code>alwaysback</code> callback to all function signatures, with the accompanying checks to ensure it is safely callable, or 2) always write our callback/errback to handle errors internally, and be sure to invoke <code>alwaysback</code> in all cases.</p>

<h1>Summary</h1>

<p>Using callbacks for asynchronous programming changes the basic programming model, creating the following situation:</p>

<ol>
<li>We can no longer use a simple call-and-return programming model</li>
<li>We can no longer handle errors using try/catch/finally</li>
<li>We must add callback and errback parameters to every function signature that <em>might eventually</em> lead to an asynchronous operation</li>
</ol>


<p>We can do better. There is another model for asynchronous programming in Javascript that more closely resembles standard call-and-return, follows a model more like try/catch/finally, and doesn&rsquo;t force us to add two callback parameters to a large number of functions.</p>

<p>Next, we&rsquo;ll look at <strong>Promises</strong>, and how they help to bring asynchronous programming back to a model that is simpler and more familiar.</p>
